# **ΑΡΧΙΤΕΚΤΟΝΙΚΗ ΥΠΟΛΟΓΙΣΤΩΝ**
### 1η Εργαστηριακή Άσκηση

**Βερβέρης Χρήστος 8079**  
**Λαμπράκη Έφη 9320**  

### **Βήμα 1ο** 

#### **Ερώτημα 1o:**  
Τις βασικές παραμέτρους του επεξεργαστή που εξομοιώνει ο gem5 όσον αφορά το υποσύστημα μνήμης τις βλέπουμε από το αρχείο
my_gem5/configs/common/Option.py

|     Caches         | Size          | Associativity |
| :---:             |    :----:     |   :----:      |  
| L1 Instruction    | 32 kB         | 2             |
| L1 Data           | 64 kB         | 2             |
| L2 Cache          | 2 MB          | 8             |

Μέγεθος cacheline_size = 64

#### **Ερώτημα 2o:**   

Τρέχοντας όλα τα benchmark με τις default τιμές τους (δηλ. **--cpu-clock = 2 GHz**) πήραμε τα εξής αποτελέσματα.

|    Specs    | Sim.seconds     | CPI       | Missrates.l1i | Missrates.l1d | Missrates.l2d |
| :---:         |    :----:     |   :----:  | :---:         |    :----:     |   :----:      |
| specbzip      | 0.083982      | 1.679650  | 0.000077      | 0.014798      | 0.282163      |
| spechmmer     | 0.059396      | 1.187917  | 0.000221      | 0.001637      | 0.339178      |
| speclibm      | 0.174671      | 3.493415  | 0.060972      | 0.000094      | 0.999944      |
| specmcf       | 0.064955      | 1.299095  | 0.023612      | 0.002108      | 0.055046      |
| specsjeng     | 0.513528      | 10.270554 | 0.000020      | 0.121831      | 0.999972      |

#### **Ερώτημα 3ο:**  

Εκτελώντας ξανά τα παραπάνω benchmarks με **--cpu-clock = 1 GHz** πήραμε τα εξής αποτελέσματα.

|    Specs      | Sim.seconds   | CPI       | Missrates.l1i | Missrates.l1d | Missrates.l2d |
| :---:         |    :----:     |   :----:  | :---:         |    :----:     |   :----:      |
| specbzip      | 0.161025      |  1.610247 | 0.000077      | 0.014675      | 0.282157      |
| spechmmer     | 0.118530      |  1.185304 | 0.000221      | 0.001629      | 0.077747      |
| speclibm      | 0.262327      |  2.623265 | 0.060971      | 0.000094      | 0.999944      |
| specmcf       | 0.127942      |  1.279422 | 0.023627      | 0.002108      | 0.055046      |
| specsjeng     | 0.704056      |  7.040561 | 0.000020      | 0.121831      | 0.999972      |

Οι πληροφορίες για το ρολόι προέκυψαν ως εξής

|  Cpu_Clock    |  system.clk_domain.clock  |  cpu_cluster.clk_domain.clock |
| :---:         |    :----:                 |   :----:                      |
| 1 GHz         | 1000                      |  1000                         |
| 2 Ghz         | 1000                      |  500                          |

Αυτό που βλέπουμε είναι ότι το ρολόι του συστήματος μένει ίδιο και αυτό που αλλάζει είναι το ρολόι του επεξεργαστή.
Το **system_clock** συγχρονίζει όλα τα στοιχεία πάνω στην μητρική. Το **cpu_clock** αφορά το εσωτερικό ρολόι του επεξεργαστή και επειδή ο επεξεργαστής πρέπει να εκτελέσει πολλές περισσότερες εντολές το cpu_clock είναι συνήθως μεγαλύτερο απο το system_clock.

**cpu_clock = 1 GHz** σημαίνει **1.000.000.000 κύκλους ρολογιού ανά δευτερόλεπτο** ενώ αντίστοιχα **cpu_clock = 2 GHz** σημαίνει **2.000.000.000** κύκλους ρολογιού ανά δευτερόλεπτο.

Εφόσον όλα τα υπόλοιπα στοιχεία των δύο προσομοιώσεων ήταν ίδια το σύστημα με **cpu_clock = 2 GHz** είναι το **πιο γρήγορο** από τα δύο όπως αλλωστε φαίνεται κοιτώντας την στήλη **sim_seconds** των δύο πινάκων.

Όσο αυξάνουμε το cpu_clock το sim_seconds γίνεται μικρότερο που σημαίνει ότι το πρόγραμμα μας εκτελείται πιο γρήγορα. Στα δικά μας παραδείγματα παρατηρούμε ότι το **sim_seconds στα 2 GHz** είναι **περίπου το μισό** από αυτό στα **1 Ghz**. Επομένως, υπάρχει ένα αρκετά **καλό scaling**.

### **Βήμα 2ο** 

#### **Ερώτημα 1ο:**

Για να αυτοματοποιήσουμε τις δοκιμές που χρειάστηκαν, γράψαμε ένα bash script για κάθε spec, στο οποίο κρατάμε όλες τις παραμέτρους σε default και αλλάζουμε σε ένα while loop τις τιμές μίας παραμέτρου κάθε φορά. 

Η διαδικασία που ακολουθήσαμε για να τρέξουμε τα bash scripts ήταν η εξής. Μέσα στον φάκελο **my_gem5** δημιουργήσαμε έναν φάκελο Scripts. Μέσα στον φάκελο **Scripts** τοποθετήσαμε όλα τα bash scripts που αναφέρθηκαν παραπάνω. Στην συνέχεια, γράψαμε τα εξής στο terminal:

**Πχ για το bzip spec**

_Μετακίνηση στον φάκελο my_gem5_  
**cd my_gem5/**  
_Άδεια εκτέλεσης_  
**chmod +x Scripts/bzipSpecs.sh**  
_Εκτέλεση αρχείου_  
**./Scripts/bzipSpecs.sh**  

Στη συνέχεια για την συλλογή και επεξεργασία των αποτελεσμάτων κατεβάσαμε το script  που δινόταν (read_results.sh) και γράψαμε για τα αποτελέσματα κάθε spec το script που περιλαμβάνει τους φακέλους των αποτελεσμάτων σύμφωνα με το πρότυπο που δίνεται στην εκφώνηση. Όλα αυτά τα scripts τα μεταφέραμε μέσα στον φάκελο my_gem5. Στη συνέχεια, γράψαμε τα εξής στο terminal.

**Πχ για το bzip spec**

**bash read_results.sh benchmark-scpipt_bzip.ini**

Τα script περιλαμβάνονται στον φάκελο Scripts που ανέβηκε στο github. 

#### **Ερώτημα 2ο:**

Ακολουθούν γραφήματα που δείχνουν την επίδραση κάθε παράγοντα στην απόδοση κάθε benchmark:

![bzip specs](https://raw.githubusercontent.com/elampraki/gem5/master/Lab2/Images/Bzip.png)

![hmmer specs](https://raw.githubusercontent.com/elampraki/gem5/master/Lab2/Images/Hmmer.png)

![libm specs](https://raw.githubusercontent.com/elampraki/gem5/master/Lab2/Images/Libm.png)

![mcf specs](https://raw.githubusercontent.com/elampraki/gem5/master/Lab2/Images/Mcf.png)

![sjeng specs](https://raw.githubusercontent.com/elampraki/gem5/master/Lab2/Images/Sjeng.png)

#### Cache line size

Τα δεδομένα μεταφέρονται μεταξύ μνήμης και προσωρινής μνήμης σε μπλοκ σταθερού μεγέθους (κάναμε δοκιμές για cacheline μεγέθους 16, 32, 64, 128). Αυτό που παρατηρήσαμε ήταν, ότι σε όλες τις περιπτώσεις το **μέγεθος της cacheline** είχε την **μεγαλύτερη επίδραση στο cpi.** Μεγάλο cacheline είχε ως αποτέλεσμα μικρό cpi (με εξαίρεση το mcf όπου συνέβαινε το αντίθετο).

Αυτό μας οδηγεί στο συμπέρασμα ότι οι διεργασίες που γίνονταν εντός του κάθε spec ευνοούνταν αν ο επεξεργαστής διαχειριζόταν μπλοκ μεγέθους 128 byte. Τα δεδομένα που χρειαζόταν δηλαδή ο επεξεργαστής είχαν μεγάλο μέγεθος συνήθως, ώστε αναζητώντας τα σε μπλοκ των 128 byte είχε ως αποτέλεσμα λιγότερες μεταφορές και αναζητήσεις δεδομένων και άρα χαμηλότερο cpi.

#### L1d, L1i, L2 size

Όσον αφορά **τα μεγέθη των l1d, l1i και l2** παρατηρήσαμε ότι αύξηση του μεγέθους τους είχε ως αποτέλεσμα **μικρή ή καθόλου βελτίωση του cpi.**

Ο επεξεργαστής όταν αναζητεί κάποια πληροφορία πρώτα ελέγχει τις προσωρινές μνήμες και αν αποτύχει να βρει αυτό που θέλει σε αυτές στρέφεται στην κύρια μνήμη. Η αναζήτηση πληροφοριών στις προσωρινές μνήμες είναι πολύ πιο γρήγορη διαδικασία συγκριτικά με την αναζήτηση στην κύρια μνήμη. Επομένως, καθώς αυξάναμε το μέγεθος της l1i, lid και l2 παρατηρούσαμε μείωση του cpi. Στις περιπτώσεις όπου το cpi παρέμεινε σταθερό πιστεύουμε ότι αυτό συνέβη επειδή ο επεξεργαστής δεν έκανε χρήση όλου του μεγέθους της προσωρινης μνήμης και μάλλον επαναχρησιμοποιούσε δεδομένα που είχαν ήδη αποθηκευτεί σε αυτές.

#### Associativity

Τέλος, αύξηση του **associativity** οδηγούσε σε **μικρή ή καθόλου βελτίωση του cpi.**

Οι προσωρινές μνήμες με μεγάλο associativity έχουν χαμηλότερο missrate γιατί όταν γίνεται αντιγραφή των δεδομένων από την μνήμη στην προσωρινή μνήμη η αντιγραφή μπορεί να γίνει σε 2, 4 ή σε 8 διαφορετικές θέσεις αναλόγως ποια θέση είναι ελεύθερη. Το γεγονός αυτό μειώνει τις πιθανότητες να γίνει αντικατάσταση δεδομένων μέσα στην προσωρινή μνήμη και άρα λιγότερο ψάξιμο πληροφοριών στην κύρια μνήμη. Από την άλλη βέβαια, όσο πιο μεγάλο είναι το associativity τόσες πιο πολλές πιθανές θέσεις μιας πληροφορίας έχει να αναζητήσει ο επεξεργαστής. 

Τα αποτελέσματα μας, μας οδηγούν στο συμπέρασμα ότι στα περισσότερα specs αρκούσε associativity = 2 καθώς δύο πιθανές θέσεις για εγγραφή στη προσωρινή μνήμη ήταν αρκετές ώστε να μην γίνει αντικατάσταση δεδομένων σε αυτές.

Τέλος, βλέποντας τα διαγράμματα και με βάση όσα αναφέρθηκαν παραπάνω προσπαθήσαμε να πετύχουμε το βέλτιστο cpi για κάθε περίπτωση.
Πιο συγκεκριμένα για κάθε spec έχουμε τις ακόλουθες βελτιωμένες τιμές:

| Specs | l1 Data size | l1 Instr size  | l2 size   | Cacheline  | l1 Data assoc | l1 Instr assoc  | l2 assoc | CPI |
| :---:         |    :----: |   :----:  |:---:      |:----:   | :----:|:----:    |:----:  |    :----:     |
| specbzip      |  128kB    | 128kB     | 4MB       | 128     | 8     |    8     |    8   |    1.599796   |
| spechmmer     |  128kB    | 128kB     | 4MB       | 128     | 8     |    8     |    8   |    1.179450   |
| speclibm      |  128kB    | 128kB     | 4MB       | 128     | 8     |    8     |    8   |    2.576600   |
| specmcf       |  128kB    | 128kB     | 4MB       | 128     | 8     |    8     |    8   |    1.123105   |
| specsjeng     |  128kB    | 128kB     | 4MB       | 128     | 8     |    8     |    8   |    6.795093   |


### **Βήμα 3ο**

Όπως ήταν αναμενόμενο τα καλύτερα cpi προέκυψαν όταν όλες οι παράμετροι είχαν τις μέγιστες δυνατές τιμές τους. Η δημιουργία όμως, προσωρινών μνημών έχει μεγάλο κόστος και για αυτό τον λόγο είναι θεμιτό να θυσιάσουμε λίγο cpi για την μείωση του κόστους κατεσκευής του συστήματος.

Πιο συγκεκριμένα, το μέγεθος του cache line παίζει σημαντικό ρόλο στο κατασκευαστικό κόστος μιας μνήμης. Η κατασκευή επίσης, μιας προσωρινής μνήμης L1 έχει μεγαλύτερο κόστος από μια προσωρινή μνήμη L2. Τέλος, το associativity όσο αυξάνεται έχει ως αποτέλεσμα την αύξηση της πολυπλοκότητας της προσωρινής μνήμης και άρα τους κόστους κατασκευής της.

Με γνώμονα όλα τα παραπάνω δημιουργήσαμε μια συνάρτηση κόστους όπου το 100 σημαίνει μέγιστο κόστος (όταν δηλαδή όλες οι παράμετροι είναι μέγιστες εντός των επιτρεπομένων ορίων από την εκφώνηση της άσκησης). Η συνάρτηση είναι η εξής:

Cost = [ ( 1 x ( l1d_size / 16k ) + 0.5 x ( l1d_assoc / 8 ) ) + ( 1 x ( l1i_size / 16k ) + 0.5 x ( l1i_assoc / 8 ) ) + ( 0.52 x ( l2_size / 512k ) + 0.21 x ( l1d_assoc / 8 ) ) ] x 0.5 x ( cache_line / 16 )

![cost_function](https://raw.githubusercontent.com/elampraki/gem5/master/Lab2/Images/%CF%83%CF%85%CE%BD%CE%AC%CF%81%CF%84%CE%B7%CF%83%CE%B7%20%CE%BA%CF%8C%CF%83%CF%84%CE%BF%CF%85%CF%82.jpg)

Στη συνάρτηση κόστους για l1d_size = 128 kB, l1i_size = 128 kB, l2_size = 4096 kB, cacheline_size = 128, 
l1d_assoc = 8, l1i_assoc = 8, l2_assoc = 8 βγαίνει **Cost = 100.**

Βλέποντας τα διαγράμματα του βήματος 2 αλλά και με περαιτέρω δοκιμές βλέπουμε ότι δεν επηρρεάζουν όλες οι παράμετροι το cpi με τον ίδιο τρόπο και επομένως μπορούμε με κατάλληλο συνδυασμο των παραμέτρων να μειώσουμε το κόστος κρατώντας το cpi στα ίδια περίπου επίπεδα όπως φαίνεται στον παρακάτω πίνακα.

| Specs | l1 Data size | l1 instr size  | l2 size   | Cacheline  | l1 Data assoc | l1 Instr assoc  | l2 assoc | CPI |
| :---:         |    :----: |   :----:  |:---:      |:----:   | :----:|:----:    |:----:  |    :----:     |
| specbzip      |  128kB    | 32kB      | 4MB       | 128     | 4     |    2     |    4   |    1.608418   |
| spechmmer     |  64kB     | 64kB      | 4MB       | 128     | 2     |    2     |    4   |    1.181407   |
| speclibm      |  64kB     | 64kB      | 4MB       | 128     | 2     |    2     |    4   |    2.576600   |
| specmcf       |  64kB     | 64kB      | 4MB       | 128     | 2     |    4     |    4   |    1.124774   |
| specsjeng     |  32kB     | 32kB      | 4MB       | 128     | 2     |    2     |    2   |    6.795424   |

Βάζοντας τα παραπάνω μεγέθη στη συνάρτηση κόστους προκύπτει το νέο cost.
Άρα συγκρίνοντας δίπλα δίπλα το μέγιστο κόστος και απόδοση με το νέο κόστος και απόδοση.

| Specs         | Max_Cost  | Max_CPI       | Cost      | CPI           |
| :---:         |    :----: |   :----:      |:---:      |:----:         |
| specbzip      |  100      |    1.599796   | 64.32     |    1.608418   |
| spechmmer     |  100      |    1.179450   | 54.32     |    1.181407   |
| speclibm      |  100      |    2.576600   | 56.32     |    2.576600   |
| specmcf       |  100      |    1.123105   | 56.32     |    1.124774   |
| specsjeng     |  100      |    6.795093   | 37.48     |    6.795424   |

Βλέπουμε ότι ενώ το κόστος μειώθηκε σε μεγάλο βαθμό το cpi παραμένει σχεδόν ίδιο. 

Συμπεραίνουμε δηλαδή, ότι με σωστό συνδυασμό των παραμέτρων του συστήματος μπορούμε να κρατήσουμε σταθερό το cpi ενώ παράλληλα να μειώσουμε κατά πολύ το κόστος.

## ΒΙΒΛΙΟΓΡΑΦΙΑ
“Documentation - gem5.” http://gem5.org/Documentation  
“Cpu clock.” https://en.wikipedia.org/wiki/Clock_rate  
"Cycles per instruction" https://en.wikipedia.org/wiki/Cycles_per_instruction  
"Cache placement policies" https://en.wikipedia.org/wiki/Cache_placement_policies  